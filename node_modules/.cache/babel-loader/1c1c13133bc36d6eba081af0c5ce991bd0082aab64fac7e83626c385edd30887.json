{"ast":null,"code":"// src/redux/data/dataActions.js\nimport { LootBoxNFT } from './contracts'; // Ensure the contract is imported correctly\nimport defaultImage from '../../assets/images/JOINTPACK.jpg'; // Ensure the default image is correctly imported\n\nexport const initializeContract = contractAddress => {\n  return async (dispatch, getState) => {\n    try {\n      const {\n        web3,\n        account\n      } = getState().blockchain;\n      if (!web3 || !account) {\n        throw new Error(\"Web3 or account not found\");\n      }\n      if (!contractAddress) {\n        throw new Error(\"Contract address not specified\");\n      }\n      const lootBoxNFT = new web3.eth.Contract(LootBoxNFT.abi, contractAddress);\n      dispatch({\n        type: 'SET_LOOTBOXNFT_CONTRACT',\n        payload: lootBoxNFT\n      });\n    } catch (error) {\n      console.error(\"Error initializing LootBoxNFT contract:\", error);\n    }\n  };\n};\nexport const fetchData = () => {\n  return async (dispatch, getState) => {\n    try {\n      const {\n        account,\n        LootBoxNFT\n      } = getState().blockchain;\n      if (!account || !LootBoxNFT) {\n        throw new Error(\"Account or LootBoxNFT contract not found\");\n      }\n      const balance = await LootBoxNFT.methods.balanceOf(account).call();\n      const nftData = [];\n      for (let i = 0; i < balance; i++) {\n        const tokenId = await LootBoxNFT.methods.tokenOfOwnerByIndex(account, i).call();\n        nftData.push({\n          tokenId: tokenId.toString(),\n          image: defaultImage\n        }); // Convert BigInt to string and use the default image\n      }\n      dispatch({\n        type: 'SET_NFTS',\n        payload: nftData\n      });\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n};","map":{"version":3,"names":["LootBoxNFT","defaultImage","initializeContract","contractAddress","dispatch","getState","web3","account","blockchain","Error","lootBoxNFT","eth","Contract","abi","type","payload","error","console","fetchData","balance","methods","balanceOf","call","nftData","i","tokenId","tokenOfOwnerByIndex","push","toString","image"],"sources":["C:/Users/deanw/OneDrive/Desktop/GitHub/MikulPacks/src/redux/data/dataActions.js"],"sourcesContent":["// src/redux/data/dataActions.js\nimport { LootBoxNFT } from './contracts'; // Ensure the contract is imported correctly\nimport defaultImage from '../../assets/images/JOINTPACK.jpg'; // Ensure the default image is correctly imported\n\nexport const initializeContract = (contractAddress) => {\n  return async (dispatch, getState) => {\n    try {\n      const { web3, account } = getState().blockchain;\n      if (!web3 || !account) {\n        throw new Error(\"Web3 or account not found\");\n      }\n\n      if (!contractAddress) {\n        throw new Error(\"Contract address not specified\");\n      }\n\n      const lootBoxNFT = new web3.eth.Contract(LootBoxNFT.abi, contractAddress);\n      dispatch({ type: 'SET_LOOTBOXNFT_CONTRACT', payload: lootBoxNFT });\n    } catch (error) {\n      console.error(\"Error initializing LootBoxNFT contract:\", error);\n    }\n  };\n};\n\nexport const fetchData = () => {\n  return async (dispatch, getState) => {\n    try {\n      const { account, LootBoxNFT } = getState().blockchain;\n      if (!account || !LootBoxNFT) {\n        throw new Error(\"Account or LootBoxNFT contract not found\");\n      }\n\n      const balance = await LootBoxNFT.methods.balanceOf(account).call();\n      const nftData = [];\n      for (let i = 0; i < balance; i++) {\n        const tokenId = await LootBoxNFT.methods.tokenOfOwnerByIndex(account, i).call();\n        nftData.push({ tokenId: tokenId.toString(), image: defaultImage }); // Convert BigInt to string and use the default image\n      }\n      dispatch({ type: 'SET_NFTS', payload: nftData });\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n};"],"mappings":"AAAA;AACA,SAASA,UAAU,QAAQ,aAAa,CAAC,CAAC;AAC1C,OAAOC,YAAY,MAAM,mCAAmC,CAAC,CAAC;;AAE9D,OAAO,MAAMC,kBAAkB,GAAIC,eAAe,IAAK;EACrD,OAAO,OAAOC,QAAQ,EAAEC,QAAQ,KAAK;IACnC,IAAI;MACF,MAAM;QAAEC,IAAI;QAAEC;MAAQ,CAAC,GAAGF,QAAQ,CAAC,CAAC,CAACG,UAAU;MAC/C,IAAI,CAACF,IAAI,IAAI,CAACC,OAAO,EAAE;QACrB,MAAM,IAAIE,KAAK,CAAC,2BAA2B,CAAC;MAC9C;MAEA,IAAI,CAACN,eAAe,EAAE;QACpB,MAAM,IAAIM,KAAK,CAAC,gCAAgC,CAAC;MACnD;MAEA,MAAMC,UAAU,GAAG,IAAIJ,IAAI,CAACK,GAAG,CAACC,QAAQ,CAACZ,UAAU,CAACa,GAAG,EAAEV,eAAe,CAAC;MACzEC,QAAQ,CAAC;QAAEU,IAAI,EAAE,yBAAyB;QAAEC,OAAO,EAAEL;MAAW,CAAC,CAAC;IACpE,CAAC,CAAC,OAAOM,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,yCAAyC,EAAEA,KAAK,CAAC;IACjE;EACF,CAAC;AACH,CAAC;AAED,OAAO,MAAME,SAAS,GAAGA,CAAA,KAAM;EAC7B,OAAO,OAAOd,QAAQ,EAAEC,QAAQ,KAAK;IACnC,IAAI;MACF,MAAM;QAAEE,OAAO;QAAEP;MAAW,CAAC,GAAGK,QAAQ,CAAC,CAAC,CAACG,UAAU;MACrD,IAAI,CAACD,OAAO,IAAI,CAACP,UAAU,EAAE;QAC3B,MAAM,IAAIS,KAAK,CAAC,0CAA0C,CAAC;MAC7D;MAEA,MAAMU,OAAO,GAAG,MAAMnB,UAAU,CAACoB,OAAO,CAACC,SAAS,CAACd,OAAO,CAAC,CAACe,IAAI,CAAC,CAAC;MAClE,MAAMC,OAAO,GAAG,EAAE;MAClB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,OAAO,EAAEK,CAAC,EAAE,EAAE;QAChC,MAAMC,OAAO,GAAG,MAAMzB,UAAU,CAACoB,OAAO,CAACM,mBAAmB,CAACnB,OAAO,EAAEiB,CAAC,CAAC,CAACF,IAAI,CAAC,CAAC;QAC/EC,OAAO,CAACI,IAAI,CAAC;UAAEF,OAAO,EAAEA,OAAO,CAACG,QAAQ,CAAC,CAAC;UAAEC,KAAK,EAAE5B;QAAa,CAAC,CAAC,CAAC,CAAC;MACtE;MACAG,QAAQ,CAAC;QAAEU,IAAI,EAAE,UAAU;QAAEC,OAAO,EAAEQ;MAAQ,CAAC,CAAC;IAClD,CAAC,CAAC,OAAOP,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;IAC9C;EACF,CAAC;AACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}